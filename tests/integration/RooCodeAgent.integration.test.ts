import { RooCodeAgent } from '../../src/agents/RooCodeAgent';
import { setupTestProject, runRuler, teardownTestProject } from '../harness';
import * as fs from 'fs/promises';
import * as path from 'path';

describe('RooCodeAgent Integration', () => {
  let testProject: { projectRoot: string };

  beforeEach(async () => {
    testProject = await setupTestProject({
      '.ruler/test.md': '# Test rules for RooCode'
    });
  });

  afterEach(async () => {
    await teardownTestProject(testProject.projectRoot);
  });

  it('creates AGENTS.md and empty .roo/mcp.json when no MCP config', async () => {
    const { projectRoot } = testProject;

    // Run ruler with roo agent
    runRuler('apply --agents roo', projectRoot);

    // Check AGENTS.md was created
    const agentsPath = path.join(projectRoot, 'AGENTS.md');
    const agentsContent = await fs.readFile(agentsPath, 'utf8');
    expect(agentsContent).toContain('<!-- Generated by Ruler -->');
    expect(agentsContent).toContain('# Test rules for RooCode');

    // Check .roo/mcp.json was created
    const mcpPath = path.join(projectRoot, '.roo', 'mcp.json');
    const mcpContent = await fs.readFile(mcpPath, 'utf8');
    const mcpJson = JSON.parse(mcpContent);
    expect(mcpJson).toEqual({ mcpServers: {} });
  });

  it('creates MCP servers when ruler.toml has mcp_servers', async () => {
    const { projectRoot } = testProject;
    
    // Add ruler.toml with MCP servers
    const rulerTomlContent = `[mcp_servers.echo]
command = "echo"
args = ["hello"]

[mcp_servers.remote]
type = "http"
url = "https://api.example.com"`;
    
    await fs.writeFile(path.join(projectRoot, '.ruler', 'ruler.toml'), rulerTomlContent);

    // Run ruler with roo agent
    runRuler('apply --agents roo', projectRoot);

    // Check .roo/mcp.json has MCP servers
    const mcpPath = path.join(projectRoot, '.roo', 'mcp.json');
    const mcpContent = await fs.readFile(mcpPath, 'utf8');
    const mcpJson = JSON.parse(mcpContent);
    
    expect(mcpJson.mcpServers.echo).toEqual({
      command: 'echo',
      args: ['hello'],
      type: 'stdio'
    });
    expect(mcpJson.mcpServers.remote).toEqual({
      type: 'remote',
      url: 'https://api.example.com'
    });
  });

  it('is idempotent - second run makes no changes', async () => {
    const { projectRoot } = testProject;

    // First run
    runRuler('apply --agents roo', projectRoot);
    
    const agentsPath = path.join(projectRoot, 'AGENTS.md');
    const mcpPath = path.join(projectRoot, '.roo', 'mcp.json');
    
    const agentsStats1 = await fs.stat(agentsPath);
    const mcpStats1 = await fs.stat(mcpPath);
    
    // Wait a moment to ensure timestamps would differ if files were rewritten
    await new Promise(resolve => setTimeout(resolve, 10));
    
    // Second run
    runRuler('apply --agents roo', projectRoot);
    
    const agentsStats2 = await fs.stat(agentsPath);
    const mcpStats2 = await fs.stat(mcpPath);
    
    // Files should not have been modified
    expect(agentsStats2.mtimeMs).toBe(agentsStats1.mtimeMs);
    expect(mcpStats2.mtimeMs).toBe(mcpStats1.mtimeMs);
  });

  it('merges with existing .roo/mcp.json', async () => {
    const { projectRoot } = testProject;
    
    // Create existing .roo/mcp.json
    const existingMcp = {
      mcpServers: {
        'existing-server': {
          command: 'existing-cmd'
        }
      }
    };
    
    await fs.mkdir(path.join(projectRoot, '.roo'), { recursive: true });
    await fs.writeFile(
      path.join(projectRoot, '.roo', 'mcp.json'), 
      JSON.stringify(existingMcp, null, 2)
    );
    
    // Add ruler.toml with new servers
    const rulerTomlContent = `[mcp_servers.new-server]
command = "new-cmd"

[mcp_servers.existing-server]
command = "updated-cmd"`;
    
    await fs.writeFile(path.join(projectRoot, '.ruler', 'ruler.toml'), rulerTomlContent);

    // Run ruler
    runRuler('apply --agents roo', projectRoot);

    // Check merged result
    const mcpPath = path.join(projectRoot, '.roo', 'mcp.json');
    const mcpContent = await fs.readFile(mcpPath, 'utf8');
    const mcpJson = JSON.parse(mcpContent);
    
    expect(mcpJson.mcpServers['existing-server']).toEqual({
      command: 'updated-cmd',
      type: 'stdio'
    });
    expect(mcpJson.mcpServers['new-server']).toEqual({
      command: 'new-cmd',
      type: 'stdio'
    });
  });
});