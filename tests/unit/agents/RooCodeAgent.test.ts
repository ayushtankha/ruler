import { RooCodeAgent } from '../../../src/agents/RooCodeAgent';
import * as fs from 'fs/promises';
import * as path from 'path';
import { ensureDirExists, backupFile, writeGeneratedFile } from '../../../src/core/FileSystemUtils';

// Mock fs module
jest.mock('fs/promises');
jest.mock('../../../src/core/FileSystemUtils');

const mockedFs = jest.mocked(fs);
const mockedEnsureDirExists = jest.mocked(ensureDirExists);
const mockedBackupFile = jest.mocked(backupFile);
const mockedWriteGeneratedFile = jest.mocked(writeGeneratedFile);

describe('RooCodeAgent', () => {
  let agent: RooCodeAgent;
  const tmpDir = '/tmp/test';
  const agentsPath = path.join(tmpDir, 'AGENTS.md');
  const mcpPath = path.join(tmpDir, '.roo', 'mcp.json');

  beforeEach(() => {
    agent = new RooCodeAgent();
    jest.clearAllMocks();
  });

  describe('Basic Properties', () => {
    it('returns correct identifier', () => {
      expect(agent.getIdentifier()).toBe('roo');
    });

    it('returns correct name', () => {
      expect(agent.getName()).toBe('RooCode');
    });

    it('returns correct default output paths', () => {
      const paths = agent.getDefaultOutputPath(tmpDir);
      expect(paths.instructions).toBe(agentsPath);
      expect(paths.mcp).toBe(mcpPath);
    });

    it('supports MCP stdio', () => {
      expect(agent.supportsMcpStdio()).toBe(true);
    });

    it('supports MCP remote', () => {
      expect(agent.supportsMcpRemote()).toBe(true);
    });

    it('returns correct MCP server key', () => {
      expect(agent.getMcpServerKey()).toBe('mcpServers');
    });
  });

  describe('File Operations - No MCP Config', () => {
    it('writes AGENTS.md and creates empty .roo/mcp.json when no MCP config provided', async () => {
      // Mock files don't exist
      mockedFs.readFile.mockRejectedValue(new Error('File not found'));

      await agent.applyRulerConfig('test rules', tmpDir, null);

      // Should call super.applyRulerConfig for AGENTS.md
      expect(mockedEnsureDirExists).toHaveBeenCalledWith(path.dirname(agentsPath));
      expect(mockedWriteGeneratedFile).toHaveBeenCalledWith(
        agentsPath,
        '<!-- Generated by Ruler -->\ntest rules'
      );

      // Should create .roo directory and write empty MCP config
      expect(mockedEnsureDirExists).toHaveBeenCalledWith(path.dirname(mcpPath));
      expect(mockedWriteGeneratedFile).toHaveBeenCalledWith(
        mcpPath,
        JSON.stringify({ mcpServers: {} }, null, 2)
      );
    });

    it('skips writing when AGENTS.md content unchanged', async () => {
      const existingContent = '<!-- Generated by Ruler -->\ntest rules';
      
      // Mock AGENTS.md exists with same content and mcp.json exists with same content
      mockedFs.readFile
        .mockResolvedValueOnce(existingContent as any) // AGENTS.md
        .mockResolvedValueOnce(JSON.stringify({ mcpServers: {} }, null, 2) as any); // mcp.json

      await agent.applyRulerConfig('test rules', tmpDir, null);

      // Should not write either file since content is unchanged
      expect(mockedWriteGeneratedFile).not.toHaveBeenCalled();
    });
  });

  describe('File Operations - With MCP Config', () => {
    it('writes MCP servers to .roo/mcp.json when MCP config provided', async () => {
      const mcpConfig = {
        mcpServers: {
          'echo-server': {
            command: 'echo',
            args: ['hello']
          },
          'remote-server': {
            type: 'http',
            url: 'https://api.example.com/mcp'
          }
        }
      };

      // Mock files don't exist
      mockedFs.readFile.mockRejectedValue(new Error('File not found'));

      await agent.applyRulerConfig('test rules', tmpDir, mcpConfig);

      expect(mockedWriteGeneratedFile).toHaveBeenCalledWith(
        mcpPath,
        JSON.stringify({
          mcpServers: {
            'echo-server': {
              command: 'echo',
              args: ['hello']
            },
            'remote-server': {
              type: 'http',
              url: 'https://api.example.com/mcp'
            }
          }
        }, null, 2)
      );
    });

    it('merges new MCP servers with existing ones', async () => {
      const existingMcp = {
        mcpServers: {
          'existing-server': {
            command: 'existing',
            args: []
          }
        }
      };

      const newMcp = {
        mcpServers: {
          'new-server': {
            command: 'new',
            args: []
          },
          'existing-server': {
            command: 'updated',
            args: ['updated']
          }
        }
      };

      mockedFs.readFile
        .mockRejectedValueOnce(new Error('AGENTS.md not found')) // AGENTS.md
        .mockResolvedValueOnce(JSON.stringify(existingMcp) as any); // existing mcp.json

      await agent.applyRulerConfig('test rules', tmpDir, newMcp);

      expect(mockedWriteGeneratedFile).toHaveBeenCalledWith(
        mcpPath,
        JSON.stringify({
          mcpServers: {
            'existing-server': {
              command: 'updated',
              args: ['updated']
            },
            'new-server': {
              command: 'new',
              args: []
            }
          }
        }, null, 2)
      );
    });

    it('handles invalid existing JSON gracefully', async () => {
      const mcpConfig = {
        mcpServers: {
          'new-server': {
            command: 'new'
          }
        }
      };

      mockedFs.readFile
        .mockRejectedValueOnce(new Error('AGENTS.md not found')) // AGENTS.md
        .mockResolvedValueOnce('invalid json content' as any); // invalid mcp.json

      await agent.applyRulerConfig('test rules', tmpDir, mcpConfig);

      expect(mockedWriteGeneratedFile).toHaveBeenCalledWith(
        mcpPath,
        JSON.stringify({
          mcpServers: {
            'new-server': {
              command: 'new'
            }
          }
        }, null, 2)
      );
    });

    it('preserves existing servers when no new MCP config provided', async () => {
      const existingMcp = {
        mcpServers: {
          'existing-server': {
            command: 'existing'
          }
        }
      };

      mockedFs.readFile
        .mockRejectedValueOnce(new Error('AGENTS.md not found')) // AGENTS.md
        .mockResolvedValueOnce(JSON.stringify(existingMcp) as any); // existing mcp.json

      await agent.applyRulerConfig('test rules', tmpDir, null);

      expect(mockedWriteGeneratedFile).toHaveBeenCalledWith(
        mcpPath,
        JSON.stringify({
          mcpServers: {
            'existing-server': {
              command: 'existing'
            }
          }
        }, null, 2)
      );
    });
  });

  describe('Configuration Overrides', () => {
    it('uses custom output paths when provided in agent config', async () => {
      const customInstructionsPath = path.join(tmpDir, 'custom-instructions.md');
      const customMcpPath = path.join(tmpDir, 'custom-mcp.json');

      const agentConfig = {
        outputPathInstructions: customInstructionsPath,
        outputPathConfig: customMcpPath
      };

      mockedFs.readFile.mockRejectedValue(new Error('File not found'));

      await agent.applyRulerConfig('test rules', tmpDir, null, agentConfig);

      expect(mockedEnsureDirExists).toHaveBeenCalledWith(path.dirname(customInstructionsPath));
      expect(mockedEnsureDirExists).toHaveBeenCalledWith(path.dirname(customMcpPath));
      expect(mockedWriteGeneratedFile).toHaveBeenCalledWith(
        customMcpPath,
        JSON.stringify({ mcpServers: {} }, null, 2)
      );
    });

    it('respects backup flag', async () => {
      mockedFs.readFile.mockRejectedValue(new Error('File not found'));

      await agent.applyRulerConfig('test rules', tmpDir, null, undefined, false);

      expect(mockedBackupFile).not.toHaveBeenCalled();
    });

    it('creates backup when backup flag is true and file exists', async () => {
      mockedFs.readFile
        .mockResolvedValueOnce('existing content' as any) // AGENTS.md
        .mockResolvedValueOnce('existing mcp' as any); // mcp.json

      await agent.applyRulerConfig('test rules', tmpDir, null, undefined, true);

      expect(mockedBackupFile).toHaveBeenCalledWith(agentsPath);
      expect(mockedBackupFile).toHaveBeenCalledWith(mcpPath);
    });
  });

  describe('Idempotency', () => {
    it('is idempotent when both files unchanged', async () => {
      const existingAgentsContent = '<!-- Generated by Ruler -->\ntest rules';
      const existingMcpContent = JSON.stringify({ mcpServers: {} }, null, 2);

      mockedFs.readFile
        .mockResolvedValueOnce(existingAgentsContent as any) // AGENTS.md
        .mockResolvedValueOnce(existingMcpContent as any); // mcp.json

      await agent.applyRulerConfig('test rules', tmpDir, null);

      expect(mockedBackupFile).not.toHaveBeenCalled();
      expect(mockedWriteGeneratedFile).not.toHaveBeenCalled();
    });

    it('only writes changed files', async () => {
      const existingAgentsContent = '<!-- Generated by Ruler -->\ntest rules';
      const existingMcpContent = JSON.stringify({ mcpServers: {} }, null, 2);

      const newMcp = {
        mcpServers: {
          'new-server': {
            command: 'new'
          }
        }
      };

      mockedFs.readFile
        .mockResolvedValueOnce(existingAgentsContent as any) // AGENTS.md unchanged
        .mockResolvedValueOnce(existingMcpContent as any); // mcp.json will change

      await agent.applyRulerConfig('test rules', tmpDir, newMcp);

      // Should not write AGENTS.md since unchanged
      expect(mockedWriteGeneratedFile).not.toHaveBeenCalledWith(
        agentsPath,
        expect.anything()
      );

      // Should write MCP file since changed
      expect(mockedWriteGeneratedFile).toHaveBeenCalledWith(
        mcpPath,
        JSON.stringify({ mcpServers: { 'new-server': { command: 'new' } } }, null, 2)
      );
    });
  });
});