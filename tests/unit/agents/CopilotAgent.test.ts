import { promises as fs } from 'fs';
import * as path from 'path';
import { CopilotAgent } from '../../../src/agents/CopilotAgent';
import { AgentsMdAgent } from '../../../src/agents/AgentsMdAgent';
import { setupTestProject, teardownTestProject } from '../../harness';

describe('CopilotAgent', () => {
  it('should be defined', () => {
    expect(new CopilotAgent()).toBeDefined();
  });

  it('should extend AgentsMdAgent', () => {
    const agent = new CopilotAgent();
    expect(agent instanceof AgentsMdAgent).toBe(true);
  });

  it('should have the correct identifier', () => {
    const agent = new CopilotAgent();
    expect(agent.getIdentifier()).toBe('copilot');
  });

  it('should have the correct name', () => {
    const agent = new CopilotAgent();
    expect(agent.getName()).toBe('GitHub Copilot');
  });

  it('should support MCP stdio and remote', () => {
    const agent = new CopilotAgent();
    expect(agent.supportsMcpStdio()).toBe(true);
    expect(agent.supportsMcpRemote()).toBe(true);
  });

  it('should use servers as MCP key', () => {
    const agent = new CopilotAgent();
    expect(agent.getMcpServerKey()).toBe('servers');
  });

  it('writes rules to AGENTS.md file via base class', async () => {
    const { projectRoot } = await setupTestProject({
      '.ruler/AGENTS.md': 'Rule A',
    });
    try {
      const agent = new CopilotAgent();
      const rules = 'Combined rules\n- Rule A';

      await agent.applyRulerConfig(rules, projectRoot, null);

      // AGENTS.md should be written at the repository root
      const agentsMdPath = path.join(projectRoot, 'AGENTS.md');
      const content = await fs.readFile(agentsMdPath, 'utf8');
      expect(content).toContain('Rule A');
      expect(content).toContain('Generated by Ruler');
    } finally {
      await teardownTestProject(projectRoot);
    }
  });

  it('writes rules to both AGENTS.md and .github/copilot-instructions.md', async () => {
    const { projectRoot } = await setupTestProject({
      '.ruler/AGENTS.md': 'Rule A',
    });
    try {
      const agent = new CopilotAgent();
      const rules = 'Combined rules\n- Rule A';

      await agent.applyRulerConfig(rules, projectRoot, null);

      // Both files should exist and have the same content
      const agentsMdPath = path.join(projectRoot, 'AGENTS.md');
      const legacyPath = path.join(projectRoot, '.github', 'copilot-instructions.md');
      
      const agentsMdContent = await fs.readFile(agentsMdPath, 'utf8');
      const legacyContent = await fs.readFile(legacyPath, 'utf8');

      // Both should contain the rules
      expect(agentsMdContent).toContain('Rule A');
      expect(agentsMdContent).toContain('Generated by Ruler');
      expect(legacyContent).toContain('Rule A');
      expect(legacyContent).toContain('Generated by Ruler');

      // Both should have identical content
      expect(agentsMdContent).toBe(legacyContent);
    } finally {
      await teardownTestProject(projectRoot);
    }
  });

  it('creates backups for both files when they exist', async () => {
    const { projectRoot } = await setupTestProject({
      '.ruler/AGENTS.md': 'Rule A',
    });
    try {
      // Create existing files to be backed up
      const agentsMdPath = path.join(projectRoot, 'AGENTS.md');
      const legacyPath = path.join(projectRoot, '.github', 'copilot-instructions.md');
      
      await fs.mkdir(path.dirname(legacyPath), { recursive: true });
      await fs.writeFile(agentsMdPath, 'Existing AGENTS.md content');
      await fs.writeFile(legacyPath, 'Existing legacy content');

      const agent = new CopilotAgent();
      const rules = 'Combined rules\n- Rule A';

      await agent.applyRulerConfig(rules, projectRoot, null, undefined, true);

      // Check that backup files were created
      const agentsMdBackup = path.join(projectRoot, 'AGENTS.md.bak');
      const legacyBackup = path.join(projectRoot, '.github', 'copilot-instructions.md.bak');
      
      const agentsMdBackupContent = await fs.readFile(agentsMdBackup, 'utf8');
      const legacyBackupContent = await fs.readFile(legacyBackup, 'utf8');

      expect(agentsMdBackupContent).toBe('Existing AGENTS.md content');
      expect(legacyBackupContent).toBe('Existing legacy content');

      // Check that new content was written
      const agentsMdContent = await fs.readFile(agentsMdPath, 'utf8');
      const legacyContent = await fs.readFile(legacyPath, 'utf8');
      
      expect(agentsMdContent).toContain('Rule A');
      expect(legacyContent).toContain('Rule A');
    } finally {
      await teardownTestProject(projectRoot);
    }
  });

  it('respects --no-backup flag for both files', async () => {
    const { projectRoot } = await setupTestProject({
      '.ruler/AGENTS.md': 'Rule A',
    });
    try {
      // Create existing files
      const agentsMdPath = path.join(projectRoot, 'AGENTS.md');
      const legacyPath = path.join(projectRoot, '.github', 'copilot-instructions.md');
      
      await fs.mkdir(path.dirname(legacyPath), { recursive: true });
      await fs.writeFile(agentsMdPath, 'Existing AGENTS.md content');
      await fs.writeFile(legacyPath, 'Existing legacy content');

      const agent = new CopilotAgent();
      const rules = 'Combined rules\n- Rule A';

      await agent.applyRulerConfig(rules, projectRoot, null, undefined, false);

      // Check that no backup files were created
      const agentsMdBackup = path.join(projectRoot, 'AGENTS.md.bak');
      const legacyBackup = path.join(projectRoot, '.github', 'copilot-instructions.md.bak');
      
      const agentsMdBackupExists = await fs.access(agentsMdBackup).then(() => true).catch(() => false);
      const legacyBackupExists = await fs.access(legacyBackup).then(() => true).catch(() => false);

      expect(agentsMdBackupExists).toBe(false);
      expect(legacyBackupExists).toBe(false);

      // Check that new content was still written
      const agentsMdContent = await fs.readFile(agentsMdPath, 'utf8');
      const legacyContent = await fs.readFile(legacyPath, 'utf8');
      
      expect(agentsMdContent).toContain('Rule A');
      expect(legacyContent).toContain('Rule A');
    } finally {
      await teardownTestProject(projectRoot);
    }
  });

  it('is idempotent - does not write when content is unchanged', async () => {
    const { projectRoot } = await setupTestProject({
      '.ruler/AGENTS.md': 'Rule A',
    });
    try {
      const agent = new CopilotAgent();
      const rules = 'Combined rules\n- Rule A';

      // First apply
      await agent.applyRulerConfig(rules, projectRoot, null);

      const agentsMdPath = path.join(projectRoot, 'AGENTS.md');
      const legacyPath = path.join(projectRoot, '.github', 'copilot-instructions.md');

      // Get modification times
      const agentsMdStat1 = await fs.stat(agentsMdPath);
      const legacyStat1 = await fs.stat(legacyPath);

      // Wait a bit to ensure different timestamps if files are rewritten
      await new Promise(resolve => setTimeout(resolve, 100));

      // Second apply with same rules
      await agent.applyRulerConfig(rules, projectRoot, null);

      // Get modification times again
      const agentsMdStat2 = await fs.stat(agentsMdPath);
      const legacyStat2 = await fs.stat(legacyPath);

      // Files should not have been modified (idempotency)
      expect(agentsMdStat1.mtime.getTime()).toBe(agentsMdStat2.mtime.getTime());
      expect(legacyStat1.mtime.getTime()).toBe(legacyStat2.mtime.getTime());
    } finally {
      await teardownTestProject(projectRoot);
    }
  });
});