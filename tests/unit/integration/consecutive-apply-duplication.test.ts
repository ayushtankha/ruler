import * as fs from 'fs/promises';
import * as path from 'path';
import * as os from 'os';
import { AgentsMdAgent } from '../../../src/agents/AgentsMdAgent';
import { WindsurfAgent } from '../../../src/agents/WindsurfAgent';
import { readMarkdownFiles } from '../../../src/core/FileSystemUtils';

/**
 * Test for the specific issue mentioned in the comment:
 * "the fix isn't working. The notification `<!-- Generated by Ruler -->` is added to `AGENTS.md`, 
 * but the generated `.windsurf/rules/ruler_windsurf_instructions.md` still has the duplication."
 */
describe('Consecutive applies duplication prevention', () => {
  let tmpDir: string;
  let rulerDir: string;
  let projectRoot: string;
  let agentsMdAgent: AgentsMdAgent;
  let windsurfAgent: WindsurfAgent;

  beforeEach(async () => {
    tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), 'ruler-consecutive-test-'));
    projectRoot = tmpDir;
    rulerDir = path.join(tmpDir, '.ruler');
    await fs.mkdir(rulerDir, { recursive: true });
    
    agentsMdAgent = new AgentsMdAgent();
    windsurfAgent = new WindsurfAgent();
  });

  afterEach(async () => {
    await fs.rm(tmpDir, { recursive: true, force: true });
  });

  it('should not duplicate content in windsurf output on consecutive applies', async () => {
    // Step 1: Create initial ruler content
    const initialRulerContent = 'Initial ruler instructions from .ruler directory.';
    await fs.writeFile(path.join(rulerDir, 'instructions.md'), initialRulerContent);

    // Step 2: Simulate first apply - read markdown files and generate content
    let markdownFiles = await readMarkdownFiles(rulerDir);
    let concatenatedRules = markdownFiles.map(f => f.content).join('\n\n');
    
    // First apply - generate AGENTS.md
    await agentsMdAgent.applyRulerConfig(concatenatedRules, projectRoot, null);
    
    // First apply - generate windsurf output  
    const windsurfOutputPath = windsurfAgent.getDefaultOutputPath(projectRoot);
    await windsurfAgent.applyRulerConfig(concatenatedRules, projectRoot, null);
    
    // Read the first windsurf output
    const firstWindsurfOutput = await fs.readFile(windsurfOutputPath, 'utf8');

    // Step 3: Simulate second apply - this should NOT cause duplication
    markdownFiles = await readMarkdownFiles(rulerDir);
    concatenatedRules = markdownFiles.map(f => f.content).join('\n\n');
    
    // Second apply - should not change AGENTS.md (idempotent)
    await agentsMdAgent.applyRulerConfig(concatenatedRules, projectRoot, null);
    
    // Second apply - should not duplicate content in windsurf output
    await windsurfAgent.applyRulerConfig(concatenatedRules, projectRoot, null);
    
    // Read the second windsurf output
    const secondWindsurfOutput = await fs.readFile(windsurfOutputPath, 'utf8');

    // The windsurf output should be identical (no duplication)
    expect(secondWindsurfOutput).toBe(firstWindsurfOutput);
    
    // The concatenated rules should only contain the original ruler content once
    expect(concatenatedRules).toBe(initialRulerContent);
    expect(concatenatedRules).not.toMatch(/Initial ruler instructions.*Initial ruler instructions/s);
    
    // Verify AGENTS.md has the marker
    const agentsMdContent = await fs.readFile(path.join(projectRoot, 'AGENTS.md'), 'utf8');
    expect(agentsMdContent).toMatch(/^<!-- Generated by Ruler -->/);
  });

  it('should handle multiple consecutive applies without exponential growth', async () => {
    // Create initial ruler content
    const initialRulerContent = 'Base ruler content.';
    await fs.writeFile(path.join(rulerDir, 'AGENTS.md'), initialRulerContent);

    const expectedLength = initialRulerContent.length;
    let previousLength = 0;
    
    // Perform 3 consecutive applies
    for (let i = 0; i < 3; i++) {
      const markdownFiles = await readMarkdownFiles(rulerDir);
      const concatenatedRules = markdownFiles.map(f => f.content).join('\n\n');
      
      // Apply to both agents
      await agentsMdAgent.applyRulerConfig(concatenatedRules, projectRoot, null);
      await windsurfAgent.applyRulerConfig(concatenatedRules, projectRoot, null);
      
      // Check that concatenated rules length is stable
      expect(concatenatedRules.length).toBe(expectedLength);
      
      if (i > 0) {
        expect(concatenatedRules.length).toBe(previousLength);
      }
      previousLength = concatenatedRules.length;
    }
  });

  it('should reproduce the exact bug: duplication when only AGENTS.md exists in .ruler', async () => {
    // This test reproduces the exact scenario that causes the bug
    
    // Step 1: Start with only AGENTS.md in .ruler directory (common scenario)
    const originalRulerContent = 'Original content in .ruler/AGENTS.md';
    await fs.writeFile(path.join(rulerDir, 'AGENTS.md'), originalRulerContent);

    // Step 2: First apply - this should work fine
    let markdownFiles = await readMarkdownFiles(rulerDir);
    let concatenatedRules = markdownFiles.map(f => f.content).join('\n\n');
    
    // Generate the root AGENTS.md with marker
    await agentsMdAgent.applyRulerConfig(concatenatedRules, projectRoot, null);
    
    // Apply to windsurf agent
    await windsurfAgent.applyRulerConfig(concatenatedRules, projectRoot, null);
    const windsurfPath = windsurfAgent.getDefaultOutputPath(projectRoot);
    const firstWindsurfOutput = await fs.readFile(windsurfPath, 'utf8');

    // Step 3: Second apply - this is where the bug happens
    // The generated root AGENTS.md should be skipped, but isn't because the logic is wrong
    markdownFiles = await readMarkdownFiles(rulerDir);
    concatenatedRules = markdownFiles.map(f => f.content).join('\n\n');
    
    // This should NOT contain duplicate content
    expect(concatenatedRules).toBe(originalRulerContent);
    expect(concatenatedRules).not.toContain('<!-- Generated by Ruler -->');
    
    // Apply to windsurf agent again
    await windsurfAgent.applyRulerConfig(concatenatedRules, projectRoot, null);
    const secondWindsurfOutput = await fs.readFile(windsurfPath, 'utf8');
    
    // The windsurf output should be identical (no duplication)
    expect(secondWindsurfOutput).toBe(firstWindsurfOutput);
  });

  it('should demonstrate the ACTUAL bug: empty ruler directory case', async () => {
    // This might be the real bug - when .ruler has NO files initially
    
    // Step 1: Start with an empty .ruler directory
    // (No files in .ruler)
    
    // But let's say we have some global or other source of rules
    const someInitialRules = 'Some initial rules from somewhere';
    
    // Step 2: Simulate first apply with some rules
    await agentsMdAgent.applyRulerConfig(someInitialRules, projectRoot, null);
    
    // Now create a file in .ruler after the first apply
    await fs.writeFile(path.join(rulerDir, 'instructions.md'), 'New ruler instructions');
    
    // Step 3: Second apply - now .ruler has files, but root AGENTS.md is generated
    let markdownFiles = await readMarkdownFiles(rulerDir);
    let concatenatedRules = markdownFiles.map(f => f.content).join('\n\n');
    
    // The concatenated rules should only contain the new ruler instructions, not the generated content
    expect(concatenatedRules).toBe('New ruler instructions');
    expect(concatenatedRules).not.toContain('<!-- Generated by Ruler -->');
    expect(concatenatedRules).not.toContain(someInitialRules);
  });

  it('should try to reproduce the actual bug scenario', async () => {
    // Maybe the bug happens in a very specific scenario
    // Let me try to create a test that might fail
    
    // Scenario: Start with some content, apply, then add more content, apply again
    console.log('\n=== REPRODUCING EXACT BUG ===');
    
    // Step 1: Start with empty .ruler but some other source of rules
    // (Simulate some initial state)
    
    // Step 2: Create a file that will cause the first generation
    const initialContent = 'You are helpful.';
    await fs.writeFile(path.join(rulerDir, 'base.md'), initialContent);
    
    // First apply
    let files = await readMarkdownFiles(rulerDir);
    let rules = files.map(f => f.content).join('\n\n');
    await agentsMdAgent.applyRulerConfig(rules, projectRoot, null);
    await windsurfAgent.applyRulerConfig(rules, projectRoot, null);
    
    const windsurfPath = windsurfAgent.getDefaultOutputPath(projectRoot);
    const firstContent = await fs.readFile(windsurfPath, 'utf8');
    console.log('After first apply - windsurf content:', JSON.stringify(firstContent));
    
    // Check the root AGENTS.md
    const agentsMdPath = path.join(projectRoot, 'AGENTS.md');
    const rootContent1 = await fs.readFile(agentsMdPath, 'utf8');
    console.log('After first apply - root AGENTS.md:', JSON.stringify(rootContent1));
    
    // Step 3: Add more content to .ruler directory
    const additionalContent = 'Be concise in responses.';
    await fs.writeFile(path.join(rulerDir, 'additional.md'), additionalContent);
    
    // Second apply - this should NOT duplicate the previous content
    files = await readMarkdownFiles(rulerDir);
    console.log('Files found on second read:');
    files.forEach(f => console.log(`  - ${f.path}: ${JSON.stringify(f.content)}`));
    
    rules = files.map(f => f.content).join('\n\n');
    console.log('Concatenated rules on second apply:', JSON.stringify(rules));
    
    await agentsMdAgent.applyRulerConfig(rules, projectRoot, null);
    await windsurfAgent.applyRulerConfig(rules, projectRoot, null);
    
    const secondContent = await fs.readFile(windsurfPath, 'utf8');
    console.log('After second apply - windsurf content:', JSON.stringify(secondContent));
    
    const rootContent2 = await fs.readFile(agentsMdPath, 'utf8');
    console.log('After second apply - root AGENTS.md:', JSON.stringify(rootContent2));
    
    // Check for duplication
    const helpfulCount = (secondContent.match(/You are helpful/g) || []).length;
    expect(helpfulCount).toBe(1); // Should only appear once
  });
});