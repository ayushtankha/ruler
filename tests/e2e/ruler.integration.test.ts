import * as fs from 'fs/promises';
import * as path from 'path';
import os from 'os';
import { setupTestProject, teardownTestProject, runRulerWithInheritedStdio } from '../harness';

describe('Comprehensive Integration Test: ruler init â†’ setup â†’ apply â†’ verify', () => {
  let testProject: { projectRoot: string };

  beforeAll(async () => {
    testProject = await setupTestProject();
  });

  afterAll(async () => {
    await teardownTestProject(testProject.projectRoot);
  });

  it('executes complete CLI workflow and inspects all generated files', async () => {
    const { projectRoot } = testProject;
    
    console.log('=== COMPREHENSIVE INTEGRATION TEST ===');
    console.log(`Test project directory: ${projectRoot}`);

    // Step 1: Run ruler init
    console.log('\n1. Running ruler init...');
    runRulerWithInheritedStdio('init', projectRoot);

    // Verify init created the expected files
    const rulerDir = path.join(projectRoot, '.ruler');
    const initAgentsFile = path.join(rulerDir, 'AGENTS.md');
    const initTomlFile = path.join(rulerDir, 'ruler.toml');

    await expect(fs.stat(rulerDir)).resolves.toBeDefined();
    await expect(fs.stat(initAgentsFile)).resolves.toBeDefined();
    await expect(fs.stat(initTomlFile)).resolves.toBeDefined();

    console.log('âœ“ ruler init completed successfully');

    // Step 2: Create custom ruler.toml with 2 MCP servers (stdio and remote)
    console.log('\n2. Creating custom ruler.toml with MCP servers...');
    const customTomlContent = `# Ruler Configuration File
# Generated by comprehensive integration test

# Default agents to apply rules to
defaultAgents = ["copilot", "claude", "cursor"]

# Global MCP behavior
[mcp]
enabled = true
merge_strategy = "merge"

# --- MCP Servers ---

# Local/stdio MCP server example
[mcp_servers.filesystem_server]
command = "npx"
args = ["-y", "@modelcontextprotocol/server-filesystem", "${projectRoot}"]

[mcp_servers.filesystem_server.env]
DEBUG = "1"
PROJECT_ROOT = "${projectRoot}"

# Remote MCP server example  
[mcp_servers.remote_api]
url = "https://api.example.com/mcp"

[mcp_servers.remote_api.headers]
Authorization = "Bearer test-token-12345"
"X-API-Version" = "v1"
"Content-Type" = "application/json"

# Agent-specific configuration
[agents.cursor.mcp]
enabled = true
merge_strategy = "merge"

[agents.claude]
enabled = true
output_path = "CLAUDE.md"

[gitignore]
enabled = true
`;

    await fs.writeFile(initTomlFile, customTomlContent);
    console.log('âœ“ Custom ruler.toml created with stdio and remote MCP servers');

    // Step 3: Create custom AGENTS.md with sample instructions
    console.log('\n3. Creating custom AGENTS.md with sample instructions...');
    const customAgentsContent = `# AGENTS.md
Integration Test Sample Instructions

## General Guidelines

You are an AI coding assistant helping with software development. Follow these guidelines:

1. **Code Quality**: Write clean, readable, and maintainable code
2. **Testing**: Include comprehensive tests for new functionality
3. **Documentation**: Document complex logic and public APIs
4. **Performance**: Consider performance implications of your suggestions

## Language-Specific Rules

### TypeScript/JavaScript
- Use TypeScript for type safety
- Prefer async/await over Promise chains
- Use meaningful variable and function names
- Follow ESLint and Prettier configurations

### Testing Guidelines  
- Write unit tests for all public functions
- Use describe/it structure for test organization
- Mock external dependencies appropriately
- Aim for high test coverage

## Project Context

This is a CLI tool called "Ruler" that helps manage AI coding assistant configurations across different tools and platforms.

## Integration Test Marker
This content was generated by the comprehensive integration test.
`;

    await fs.writeFile(initAgentsFile, customAgentsContent);
    console.log('âœ“ Custom AGENTS.md created with sample instructions');

    // Step 4: Create additional markdown file for concatenation testing
    console.log('\n4. Creating additional markdown file for concatenation...');
    const extraMdFile = path.join(rulerDir, 'extra-rules.md');
    const extraMdContent = `# Extra Rules for Integration Testing

## Additional Guidelines

These are supplementary rules that should be concatenated with the main AGENTS.md file.

### Code Review Standards
- Review for security vulnerabilities
- Check for proper error handling
- Verify input validation
- Ensure proper logging

### Performance Considerations  
- Optimize database queries
- Minimize network calls
- Use caching where appropriate
- Profile memory usage

## Integration Test Verification
This content should appear in concatenated agent files after running ruler apply.
File: extra-rules.md
`;

    await fs.writeFile(extraMdFile, extraMdContent);
    console.log('âœ“ Additional markdown file created for concatenation testing');

    // Step 5: Run ruler apply
    console.log('\n5. Running ruler apply...');
    runRulerWithInheritedStdio('apply', projectRoot);
    console.log('âœ“ ruler apply completed successfully');

    // Step 6: Inspect all generated files
    console.log('\n6. Inspecting and verifying all generated files...');

    // List of expected generated files
    const expectedFiles = [
      'AGENTS.md', // Root level concatenated file
      'CLAUDE.md', // Claude-specific file
      '.github/copilot-instructions.md', // GitHub Copilot
      '.cursor/rules/ruler_cursor_instructions.mdc', // Cursor instructions
      '.gitignore', // Updated gitignore
    ];

    const generatedFiles: string[] = [];
    const fileContents: Record<string, string> = {};

    // Check each expected file
    for (const expectedFile of expectedFiles) {
      const filePath = path.join(projectRoot, expectedFile);
      try {
        const stat = await fs.stat(filePath);
        if (stat.isFile()) {
          generatedFiles.push(expectedFile);
          const content = await fs.readFile(filePath, 'utf8');
          fileContents[expectedFile] = content;
          console.log(`âœ“ Found generated file: ${expectedFile} (${content.length} characters)`);
        }
      } catch (error) {
        console.log(`âœ— Expected file not found: ${expectedFile}`);
      }
    }

    // Step 7: Verify file contents contain expected elements
    console.log('\n7. Verifying file contents...');

    // Verify root AGENTS.md contains concatenated content
    if (fileContents['AGENTS.md']) {
      expect(fileContents['AGENTS.md']).toContain('Integration Test Sample Instructions');
      expect(fileContents['AGENTS.md']).toContain('Extra Rules for Integration Testing');
      expect(fileContents['AGENTS.md']).toContain('Code Review Standards');
      console.log('âœ“ Root AGENTS.md contains expected concatenated content');
    }

    // Verify CLAUDE.md contains expected content
    if (fileContents['CLAUDE.md']) {
      expect(fileContents['CLAUDE.md']).toContain('Integration Test Sample Instructions');
      expect(fileContents['CLAUDE.md']).toContain('Extra Rules for Integration Testing');
      console.log('âœ“ CLAUDE.md contains expected content');
    }

    // Verify GitHub Copilot instructions
    if (fileContents['.github/copilot-instructions.md']) {
      expect(fileContents['.github/copilot-instructions.md']).toContain('Integration Test Sample Instructions');
      console.log('âœ“ GitHub Copilot instructions contain expected content');
    }

    // Verify Cursor instructions
    if (fileContents['.cursor/rules/ruler_cursor_instructions.mdc']) {
      expect(fileContents['.cursor/rules/ruler_cursor_instructions.mdc']).toContain('Integration Test Sample Instructions');
      console.log('âœ“ Cursor instructions contain expected content');
    }

    // Verify .gitignore contains ruler entries
    if (fileContents['.gitignore']) {
      expect(fileContents['.gitignore']).toContain('# START Ruler Generated Files');
      console.log('âœ“ .gitignore contains Ruler-generated entries');
    }

    // Step 8: Output all generated file contents for manual inspection
    console.log('\n8. OUTPUTTING ALL GENERATED FILE CONTENTS:\n');
    console.log('='.repeat(80));

    for (const [fileName, content] of Object.entries(fileContents)) {
      console.log(`\nðŸ“„ FILE: ${fileName}`);
      console.log('â”€'.repeat(60));
      console.log(content);
      console.log('â”€'.repeat(60));
    }

    // Step 9: Verify MCP configurations were processed
    console.log('\n9. Verifying MCP server configurations...');

    // Check if cursor MCP config was created
    const cursorMcpPath = path.join(projectRoot, '.cursor', 'mcp.json');
    try {
      const cursorMcpStat = await fs.stat(cursorMcpPath);
      if (cursorMcpStat.isFile()) {
        const cursorMcpContent = await fs.readFile(cursorMcpPath, 'utf8');
        const cursorMcpJson = JSON.parse(cursorMcpContent);
        
        // Check for our configured MCP servers
        expect(cursorMcpJson.mcpServers).toBeDefined();
        expect(cursorMcpJson.mcpServers.filesystem_server).toBeDefined();
        expect(cursorMcpJson.mcpServers.remote_api).toBeDefined();
        
        console.log('âœ“ Cursor MCP configuration generated successfully');
        console.log('\nðŸ“„ CURSOR MCP CONFIG:');
        console.log('â”€'.repeat(40));
        console.log(JSON.stringify(cursorMcpJson, null, 2));
        console.log('â”€'.repeat(40));
      }
    } catch (error) {
      console.log('â„¹ Cursor MCP file not found or not accessible');
    }

    // Final verification
    expect(generatedFiles.length).toBeGreaterThan(2);
    console.log(`\nâœ… INTEGRATION TEST COMPLETED SUCCESSFULLY!`);
    console.log(`Generated ${generatedFiles.length} files: ${generatedFiles.join(', ')}`);
    console.log('='.repeat(80));
  }, 30000); // 30 second timeout for the comprehensive test
});