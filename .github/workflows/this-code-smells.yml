name: This Code Smells

on:
  workflow_dispatch: {}
  schedule:
    # Hourly on Sundays (UTC); we gate to run only at 16:00 Europe/Zurich
    - cron: "0 * * * 0"

permissions:
  contents: read
  discussions: write
  models: read

env:
  CODEX_HOME: ./.github/workflows/this-code-smells
  TZ: Europe/Zurich

jobs:
  analyze:
    runs-on: ubuntu-latest
    steps:
      - name: Time gate (run only at 16:00 Europe/Zurich)
        id: gate
        if: ${{ github.event_name == 'schedule' }}
        run: |
          hour=$(TZ=Europe/Zurich date +%H)
          if [ "$hour" = "16" ]; then
            echo "run=true" >> "$GITHUB_OUTPUT"
            echo "It's 16:00 Europe/Zurich; proceeding."
          else
            echo "run=false" >> "$GITHUB_OUTPUT"
            echo "Not 16:00 Europe/Zurich; skipping subsequent steps."
          fi

      - uses: actions/checkout@v4
        if: ${{ steps.gate.outputs.run != 'false' }}

      - uses: actions/setup-node@v4
        if: ${{ steps.gate.outputs.run != 'false' }}
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install Codex CLI
        if: ${{ steps.gate.outputs.run != 'false' }}
        run: |
          npm install -g @openai/codex
          codex --version

      - name: Run Codex analysis
        if: ${{ steps.gate.outputs.run != 'false' }}
        env:
          # GITHUB_TOKEN is granted models: read above and used as API key for GitHub Models
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          # Enable verbose internal logs from the CLI
          RUST_LOG: debug
        run: |
          set -o pipefail
          mkdir -p "$RUNNER_TEMP"
          # Run codex non-interactively with our prompt; read-only sandbox; stream full logs to Actions while capturing to file
          codex exec --sandbox read-only < "$CODEX_HOME/prompt.md" 2>&1 | tee "$RUNNER_TEMP/raw_report.md"

          # Extract only the content between our markers
          awk '/^---BEGIN REPORT---$/ {flag=1; next} /^---END REPORT---$/ {flag=0} flag' "$RUNNER_TEMP/raw_report.md" > "$RUNNER_TEMP/report.md"

          if [ ! -s "$RUNNER_TEMP/report.md" ]; then
            echo "Report markers not found or empty report produced"
            echo "First 200 lines of raw output for debugging:"
            head -n 200 "$RUNNER_TEMP/raw_report.md" || true
            exit 1
          fi

      - name: Resolve Discussion category ID
        if: ${{ steps.gate.outputs.run != 'false' }}
        id: cat
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          owner="intellectronica"
          repo="ruler"
          gh api graphql -f query='
            query($owner:String!,$repo:String!){
              repository(owner:$owner,name:$repo){
                discussionCategories(first:100){
                  nodes{ id name }
                }
              }
            }' -F owner="$owner" -F repo="$repo" > cat.json
          cat_id=$(jq -r '.data.repository.discussionCategories.nodes[] | select(.name=="Workflow") | .id' cat.json)
          if [ -z "$cat_id" ]; then echo "Workflow discussion category not found"; exit 1; fi
          echo "id=$cat_id" >> "$GITHUB_OUTPUT"

      - name: Create Discussion
        if: ${{ steps.gate.outputs.run != 'false' }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          owner="intellectronica"
          repo="ruler"
          repo_id=$(gh api "repos/$owner/$repo" --jq .node_id)
          if [ -z "$repo_id" ]; then echo "Failed to get repository node_id"; exit 1; fi

          title="This Codebase Smells! [$(TZ=Europe/Zurich date +%F)]"

          # JSON-escape the report body safely
          body_json=$(jq -Rs . < "$RUNNER_TEMP/report.md")

          # Build GraphQL payload
          jq -n --arg repoId "$repo_id" \
                --arg catId "${{ steps.cat.outputs.id }}" \
                --arg title "$title" \
                --argjson body "$body_json" \
                '{
                   query: "mutation($repoId:ID!,$categoryId:ID!,$title:String!,$body:String!){ createDiscussion(input:{repositoryId:$repoId, categoryId:$categoryId, title:$title, body:$body}){ discussion{ url } } }",
                   variables: { repoId: $repoId, categoryId: $catId, title: $title, body: $body }
                 }' > payload.json

          gh api graphql --input payload.json -q '.data.createDiscussion.discussion.url' | tee discussion_url.txt

      - name: Show Discussion URL
        if: ${{ steps.gate.outputs.run != 'false' }}
        run: |
          echo "Discussion created:"
          cat discussion_url.txt
