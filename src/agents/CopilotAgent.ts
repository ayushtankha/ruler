import * as path from 'path';
import { IAgent, IAgentConfig } from './IAgent';
import { AgentsMdAgent } from './AgentsMdAgent';
import {
  backupFile,
  ensureDirExists,
  writeGeneratedFile,
} from '../core/FileSystemUtils';
import { promises as fs } from 'fs';

/**
 * GitHub Copilot agent adapter.
 * Writes to both AGENTS.md (for web-based GitHub Copilot) and
 * .github/copilot-instructions.md (for VS Code extension compatibility).
 */
export class CopilotAgent implements IAgent {
  private agentsMdAgent = new AgentsMdAgent();

  getIdentifier(): string {
    return 'copilot';
  }

  getName(): string {
    return 'GitHub Copilot';
  }

  /**
   * Returns multiple output paths to ensure both files are added to .gitignore.
   */
  getDefaultOutputPath(projectRoot: string): Record<string, string> {
    return {
      instructions: path.join(projectRoot, 'AGENTS.md'),
      legacy: path.join(projectRoot, '.github', 'copilot-instructions.md'),
    };
  }

  async applyRulerConfig(
    concatenatedRules: string,
    projectRoot: string,
    rulerMcpJson: Record<string, unknown> | null,
    agentConfig?: IAgentConfig,
    backup = true,
  ): Promise<void> {
    // First, write to AGENTS.md using the existing AgentsMdAgent infrastructure
    await this.agentsMdAgent.applyRulerConfig(
      concatenatedRules,
      projectRoot,
      null, // No MCP config needed for the instructions file
      {
        // Preserve explicit outputPath precedence semantics if provided
        outputPath:
          agentConfig?.outputPath || agentConfig?.outputPathInstructions,
      },
      backup,
    );

    // Additionally write to .github/copilot-instructions.md for VS Code extension compatibility
    const outputPaths = this.getDefaultOutputPath(projectRoot);
    const legacyPath = path.resolve(projectRoot, outputPaths.legacy);

    // Add marker comment to the content to identify it as generated
    const contentWithMarker = `<!-- Generated by Ruler -->\n${concatenatedRules}`;

    await ensureDirExists(path.dirname(legacyPath));

    // Check if content has changed (idempotency)
    let existingLegacy: string | null = null;
    try {
      existingLegacy = await fs.readFile(legacyPath, 'utf8');
    } catch {
      existingLegacy = null;
    }

    if (existingLegacy === null || existingLegacy !== contentWithMarker) {
      if (backup) {
        await backupFile(legacyPath);
      }
      await writeGeneratedFile(legacyPath, contentWithMarker);
    }
  }

  getMcpServerKey(): string {
    return 'servers';
  }

  supportsMcpStdio(): boolean {
    return true;
  }

  supportsMcpRemote(): boolean {
    return true;
  }
}
